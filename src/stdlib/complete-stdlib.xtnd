global rounding_cutoff := 1e-7;
global digits_after_decimal := 6;

transpose([m,n] rng) {
  [n,m] ret := rng[column(),row()];
  return ret;
}

isNumber(x) {
  return typeof(x) == "Number";
}

isEmpty(x) {
  return typeof(x) == "Empty";
}

sum_column([m,1] rng) {
  [m,1] running_sum;
  running_sum[0,0] = #rng;
  running_sum[1:,0] = running_sum[[-1]] + #rng;
  return running_sum[-1];
}

sum([m,n] rng) {
  /* Returns the sum of the values in the range, skipping any values that are non-numeric */
  [m,n] numbers := isNumber(#rng) ? #rng : 0;
  [1,n] column_sums := sum_column(numbers[:,]);
  return sum_column(transpose(column_sums));
}

nmax(n1, n2) {
  return switch {
    case isNumber(n1) && isNumber(n2):
      n1 > n2 ? n1 : n2;
    case isNumber(n1):
      n1;
    case isNumber(n2):
      n2;
    default:
      empty;
  };
}

max_column([m,1] rng) {
  [m,1] running_max;
  running_max[0,0] = #rng;
  running_max[1:,0] = nmax(running_max[[-1]], #rng);
  return running_max[-1];
}

max([m,n] rng) {
  /* Returns the sum of the values in the range, skipping any values that are non-numeric */
  [m,n] numbers := isNumber(#rng) ? #rng : empty;
  [1,n] column_maxs := max_column(rng[:,]);
  return max_column(transpose(column_maxs));
}

colRange(start, end) {
  [end-start, 1] ret;
  ret[0,0] = start;
  ret[1:,0] = ret[[-1]] + 1;
  return ret;
}

match([num_rows, 1] list, val) {
  [num_rows, 1] amt_to_add, final_index;
  amt_to_add[0,0] = val == #list ? 0 : 1;
  amt_to_add[1:,0] = (amt_to_add[[-1]] == 0 || val == #list) ? 0 : 1;
  final_index[0,0] = 0;
  final_index[1:,0] = final_index[[-1]] + amt_to_add[[-1]];
  return amt_to_add[-1] == 0 ? final_index[-1] : empty;
}

toUpper(text) {
  val := toASCII(text);
  val_s := size(val);
  [val_s[0],val_s[1]] result := #val >= 97 && #val <= 122 ? #val - 32 : #val;
  return fromASCII(result);
}

toLower(text) {
  val := toASCII(text);
  val_s := size(val);
  [val_s[0],val_s[1]] result := #val >= 65 && #val <= 90 ? #val + 32 : #val;
  return fromASCII(result);
}

left(str, num_chars) {
  return fromASCII(toASCII(str)[:num_chars]);
}

right(str, num_chars) {
  return fromASCII(toASCII(str)[-num_chars:]);
}

substring(str, start, length) {
  return fromASCII(toASCII(str)[start:start+length]);
}

concatRow([1,n] cells, joiner) {
  [1,n] accum;
  accum[0,0] = #cells;
  accum[0,1:] = accum[[-1]] + joiner + #cells;
  return accum[-1];
}

toRangeLiteral([m,n] rng) {
  [m,n] strings := toLiteral(#rng);
  [m,1] rows := concatRow(strings[,:], ", ");
  return "{" + concatRow(transpose(rows), ";\n") + "}";
}

toLiteral(arg) {
  return switch(typeof(arg)) {
    case "Number":
      to_string(arg);
    case "String":
      "\"" + arg + "\"";
    case "Empty":
      "empty";
    case "Range":
      toRangeLiteral(arg);
  };
}

sign(arg) {
  return switch {
    case arg > 0: 1;
    case arg < 0: -1;
    case arg == 0: 0;
  };
}

repeat(str, num) {
  [1,num] copies := str;
  return concatRow(copies,"");
}

stringOfPositiveInteger(arg) {
  num_digits := 1 + floor(log10(arg));
  [1,num_digits] digits := floor(arg/10**(num_digits-1-column())) % 10;
  [1,num_digits] ascii_digits := 48 + #digits;
  return fromASCII(ascii_digits);
}

padLeft(str, pad_char, total_length) {
  existing_length := len(str);
  padding := repeat(pad_char, total_length - len(str));
  return existing_length < total_length ? (padding + str) : str;
}

toString(arg) {
  positive_arg := fabs(arg);
  integer_part := round(positive_arg, 0);
  is_integral_enough := fabs(arg-integer_part) < rounding_cutoff;
  floating_part := round(10 ** digits_after_decimal * (positive_arg - floor(positive_arg)),0);
  positive_part := stringOfPositiveInteger(positive_arg) + (is_integral_enough ? "" : "." + padLeft(stringOfPositiveInteger(floating_part), "0", digits_after_decimal));

  return switch(typeof(arg)) {
    case "Number":
      switch {
        case isNaN(arg):
          "NaN";
        case isInfinite(arg) == -1:
          "-Inf";
        case isInfinite(arg) == 1:
          "Inf";
        case sign(arg) == 0:
          "0";
        case sign(arg) == 1:
            positive_part;
        case sign(arg) == -1:
          "-" + positive_part;
        default:
          "Encountered a number that is neither NaN, +Inf, -Inf, 0, positive or negative";
      };
    case "String":
      arg;
    case "Empty":
      "empty";
    case "Range":
      toRangeLiteral(arg);
  };
}
