global rounding_cutoff := 1e-7;
global digits_after_decimal := 6;

extern "stdlib.a" {
  sin(val);
  cos(val);
  tan(val);
  acos(val);
  asin(val);
  atan(val);
  sinh(val);
  cosh(val);
  tanh(val);
  exp(val);
  log(val);
  log10(val);
  sqrt(val);
  ceil(val);
  fabs(val);
  floor(val);
  isNaN(val);
  len(str);
  round(val, number_of_digits);
  isInfinite(val);
  get_stdin();
  get_stdout();
  get_stderr();
  open(filename, mode);
  close(file_handle);
  read(file_handle, num_bytes);
  readline(file_handle);
  write(file_handle, buffer);
  toASCII(val);
  fromASCII(val);
  plot(val);
  bar_chart(file_handle, labels, vals);
  line_chart(file_handle, labels, x_vals);
  parseFloat(val);
}

global STDIN := get_stdin();
global STDOUT := get_stdout();
global STDERR := get_stderr();

transpose([m,n] rng) {
  [n,m] ret := rng[column(),row()];
  return ret;
}

print_endline(val) {
  return write(STDOUT, toString(val) + "\n");
}

concatRow([1,n] cells, joiner) {
  [1,n] accum;
  accum[0,0] = #cells;
  accum[0,1:] = accum[[-1]] + joiner + #cells;
  return accum[-1];
}

toRangeLiteral([m,n] rng) {
  [m,n] strings := toLiteral(#rng);
  [m,1] rows := concatRow(strings[,:], ", ");
  return "{" + concatRow(transpose(rows), ";\n") + "}";
}

toLiteral(arg) {
  return switch(typeof(arg)) {
    case "Number":
      toString(arg);
    case "String":
      "\"" + arg + "\"";
    case "Empty":
      "empty";
    case "Range":
      toRangeLiteral(arg);
  };
}

repeat(str, num) {
  [1,num] copies := str;
  return concatRow(copies,"");
}

stringOfPositiveInteger(arg) {
  num_digits := 1 + floor(log10(arg));
  [1,num_digits] digits := floor(arg/10**(num_digits-1-column())) % 10;
  [1,num_digits] ascii_digits := 48 + #digits;
  return arg < 1 ? "0" : fromASCII(ascii_digits);
}

padLeft(str, pad_char, total_length) {
  existing_length := len(str);
  padding := repeat(pad_char, total_length - len(str));
  return existing_length < total_length ? (padding + str) : str;
}

toString(arg) {
  positive_arg := fabs(arg);
  closest_integer := round(positive_arg, 0);
  is_integral_enough := fabs(positive_arg-closest_integer) < rounding_cutoff;
  floating_part := round(10 ** digits_after_decimal * (positive_arg - floor(positive_arg)),0);
  positive_part := stringOfPositiveInteger(floor(positive_arg)) + (is_integral_enough ? "" : "." + padLeft(stringOfPositiveInteger(floating_part), "0", digits_after_decimal));

  return switch(typeof(arg)) {
    case "Number":
      switch {
        case isNaN(arg):
          "NaN";
        case isInfinite(arg) == -1:
          "-Inf";
        case isInfinite(arg) == 1:
          "Inf";
        case sign(arg) == 0:
          "0";
        case sign(arg) == 1:
            positive_part;
        case sign(arg) == -1:
          "-" + positive_part;
        default:
          "Encountered a number that is neither NaN, +Inf, -Inf, 0, positive or negative";
      };
    case "String":
      arg;
    case "Empty":
      "empty";
    case "Range":
      toRangeLiteral(arg);
  };
}

sign(arg) {
  return switch {
    case arg > 0: 1;
    case arg < 0: -1;
    case arg == 0: 0;
  };
}
