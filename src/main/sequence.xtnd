[_,2] computeSequenceAlignment([m,1] seq1, [n,1] seq2,
matchReward, mismatchPenalty, gapPenalty) {

  /*  ERRORS - grammar doesn't allow multiple variables to be declared:
  [m, n] scoreFromMatch, scoreFromLeft, scoreFromTop;
  [m, n] step, path;
  */


  [1,n] seq2T := transpose(seq2);

  [m+1,n+1] score;

  score[0, 0] = 0;
  score[1:,0] = score[[-1],] + gapPenalty;
  score[0,1:] = score[,[-1]] + gapPenalty;
  score[1:,1:] = nmax(scoreFromMatch[[-1],[-1]],
      nmax(scoreFromLeft[[-1],[-1]], scoreFromTop[[-1],[-1]]));

  scoreFromMatch = #score + (#seq1 == #seq2T) ?
      matchReward : mismatchPenalty;
  scoreFromLeft = score[[1],] + gapPenalty;
  scoreFromTop = score[,[1]] + gapPenalty;

  step = (#scoreFromMatch >= #scoreFromLeft) ?
      ((#scoreFromMatch >= #scoreFromTop) ? DDD : TTT) :
      ((#scoreFromLeft  >= #scoreFromTop) ? LLL : TTT);

  path[-1,-1] = 1;
  path[-1,:-1] = (step[,[1]] == LLL && !isEmpty(path[,[1]])) ? 1 + path[,[1]] : empty;
  path[:-1,-1] = (step[[1],] == TTT && !isEmpty(path[[1],])) ? 1 + path[[1],] : empty;
  path[:-1,:-1] = switch () {
    case step[[1],[1]] == DDD && !isEmpty(path[[1],[1]]):
      1 + path[[1],[1]];
    case step[,[1]] == LLL && !isEmpty(path[,[1]]):
      1 + path[,[1]];
    case step[[1],] == TTT && !isEmpty(path[[1],]):
      1 + path[[1],];
  };

  pathLen := path[0,0];
  [m, 1] seq1Positions := pathLen - rmax(path[,:]);
  [1, n] seq2PositionsT := pathLen - rmax(path[:,]);
  [n, 1] seq2Positions := transpose(seq2PositionsT);
  [pathLen, 1] resIdx := colRange(0, pathLength);
  [pathLen, 1] seq1Loc := match(resIdx, seq1Positions);
  [pathLen, 1] seq2Loc := match(resIdx, seq2Positions);

  [pathLength, 2] results;
  results[:,0] = seq1[seq1Loc];
  results[:,1] = seq2[seq2Loc];

  return results;
}
