\section{Introduction to Extend}
	Extend is a domain-specific programming language used to designate ranges of cells as reusable functions. It is a dynamically-typed, statically-scoped, declarative language that uses lazy evaluation to carry out computations. Once computed, all values are immutable. In order to offer the best performance, Extend compiles down to LLVM.

	Extend's syntax is meant to provide clear punctuation and easily understandable cell range access specifications, while borrowing elements from languages with C-style syntax for ease of development. Despite these syntactic similarities, the semantics of an Extend program have more in common with a spreadsheet such as Microsoft Excel than imperative languages such as C, Java or Python.

\section{Structure of an Extend Program}
\label{sec:Grammar}
	An Extend program consists of one or more source files. A source file can contain any number of import directives, global variable declarations, function definitions, and external library declarations, in any order.
	\subsection{Import Statements}
		Import statements in Extend are written with \texttt{import}, followed by the name of a file in double quotes, and terminated with a semicolon. The syntax is as follows:
		\begin{lstlisting}
import "string.xtnd";
		\end{lstlisting}
		Extend imports act like \texttt{\#include} in C, except that multiple imports of the same file are ignored. The imports are all aggregated into a single namespace.
	\subsection{Global Variables}
		In essence, global variable declarations function as constants in Extend. They are written with the keyword \texttt{global}, followed by a variable declaration in the same form as a variable declaration within a function as described in section~\ref{sec:vardecl}. As with local variables, the cell values of a global variable, once computed, are immutable. A few examples follow:
		\lstinputlisting{./samples/global.xtnd}
	\subsection{Function Definitions}
		Function definitions, which comprise the bulk of an Extend program, are described in detail in section~\ref{sec:Functions}.
	\subsection{External Library Declarations}
	  An external library is declared with the \texttt{extern} keyword, followed by the name of an object file in double quotes, followed by a semicolon-delimited list of external function declarations enclosed by curly braces. A library declaration informs the compiler of the functions' names and signatures and instructs the compiler to link the
		object file when producing an executable. An external function declared as \texttt{foo} will call an appropriately written C function \texttt{\detokenize{extend_foo}}. An example follows:
		\lstinputlisting{./samples/extern.xtnd}
		This declaration would cause the compiler to link \texttt{mylib.o} and would make the C functions \texttt{\detokenize{extend_foo}} and \texttt{\detokenize{extend_bar}} available to Extend programs as \texttt{foo} and \texttt{bar} respectively. The required signature and format of the external functions is specified precisely in section~\ref{sec:ExternFunctionSignatures}.
\section{Types and Literals}
		Extend has three primitive data types, \textbf{Number}, \textbf{String}, and \textbf{Empty}, and one composite type, \textbf{Range}.
	\subsection{Primitive Data Types}
		A \textbf{Number} is an immutable primitive value corresponding to a double-precision 64-bit binary format IEEE 754 value. Numbers can be written in an Extend source file as either integer or floating point constants; both are represented internally as floating-point values. There is no separate type representing an integer.

		A \textbf{String} is a immutable primitive value that is internally represented a C-style null-terminated byte array corresponding to ASCII values. A string can be written in an Extend source file as a sequence of characters enclosed in double quotes, with the usual escaping conventions. Extend does not allow for slicing of strings to access specific characters; access to the contents of a string will only be available through standard library functions.

		The \textbf{Empty} type can be written as the keyword \texttt{empty}, and serves a similar function to \texttt{NULL} in SQL; it represents the absence of a value.
		\newline
		\begin{table}[H]
		\centering
		\begin{tabular} {| l | l |}
			\hline
			\textbf{Primitive Data Types} & \textbf{Examples} \\ \hline
			Number & \texttt{42 or -5 or 2.71828 or 314159e-5} \\ \hline
			String & \texttt{"Hello, World!\textbackslash n" or "foo" or ""} \\ \hline
			Empty & \texttt{empty} \\ \hline
		\end{tabular}
		\end{table}
	\subsection{Ranges}
		Extend has one composite type, \textbf{Range}. A range borrows conceptually from spreadsheets; it is a group of cells with two dimensions, described as rows and columns. Each cell contains a formula that either evaluates to a Number, a String, or another Range. Cell formulas are described in detail in section~\ref{sec:formula}. A range can either be declared as described in section~\ref{sec:vardecl} or with a range literal expression. Ranges can be nested arbitrarily deeply and can be used to represent (immutable) lists, matrices, or more complicated data structures.
\subsubsection{Range Literals}
		A range literal is a semicolon-delimited list of rows, enclosed in curly brackets. Each row is a comma-delimited list of numbers, strings, or range literals. A few examples follow:
		\lstinputlisting{./samples/legal_range_literals.xtnd}
