\section{Expressions}
	Expressions in Extend allows for arithmetic and boolean operations, function calls, conditional branching, and extraction of contents of other variables. The sections for boolean and conditional operators refer to truthy and falsey values. Any number besides zero is truthy; zero is falsey. \textbf{empty} is neither truthy nor falsey. 
		\subsection{Arithmetic Operators} 
			The arithmetic operators listed below take one or two expressions and return a number, if neither expression is empty, or empty, if either expression is empty. Operators grouped within the same inner box have the same level of precedence, and are listed from highest precedence to lowest precedence. All of the binary operators, with the exception of exponentiation, are left-associative. Exponentiation, bitwise negation, and unary negation are right-associative.
			\begin{table}[H]
			\begin{tabular}{ |p{2cm}|p{3cm}|p{8cm}|  }
			\hline
			\textbf{Operator} & \textbf{Description} & \textbf{Definition} \\ \hline
			\texttt{\~} & \texttt{Bitwise NOT } & {Performs a bitwise negation on the binary representation of an expression.} \\
			\texttt{-} & \texttt{Unary negation} & {A simple negative sign to negate expressions.} \\ \hline
			\texttt{**} & \texttt{Power} & {Returns the first expression raised to the power of the second expression} \\ \hline
			\texttt{*} & \texttt{Multiplication} & {Multiplies two expressions} \\
			\texttt{/} & \texttt{Division} & {Divides first expression by second}. \\
			\texttt{\%} & \texttt{Modulo} & {Finds the remainder by dividing the expression on the left side of the modulo by the right side expression.} \\
			\texttt{<<} & \texttt{Left Shift} & {Performs a bitwise left shift on the binary representation of an expression.} \\
			\texttt{>>} & \texttt{Right Shift} & {Performs a bitwise right shift on the binary representation of an expression.} \\
			\texttt{\&} & \texttt{Bitwise AND} & {Performs a bitwise AND between two expressions. If both expressions have a 1 at the same digit, the resultant expression will have a 1 there; otherwise, it is 0.} \\ \hline
			\texttt{+} & \texttt{Addition} & {Adds two expressions together.} \\
			\texttt{-} & \texttt{Subtraction} & {Subtracts second expression from first.} \\
			\texttt{|} & \texttt{Bitwise OR} & {Performs a bitwise OR between two expressions. If at least one of the expressions has a one at the same digit, the resultant expression will have a 1 there; otherwise, it is 0.} \\
			\texttt{\^} & \texttt{Bitwise XOR} & {Performs a bitwise exclusive OR between two expressions. If exactly one of the expressions has a one in the same digit, the resultant expression will have a 1 there; otherwise it is 0.} \\ \hline
			\end{tabular}
			\end{table}
		\subsection{Boolean Operators}
			These operators take one or two expressions and evaluate to empty, if either expression is empty, or to 0 or 1 if both expressions are numeric. Operators grouped within the same inner box have the same level of precedence and are listed from highest precedence to lowest precedence. All of these operators besides logical negation are left-associative.
			\begin{table}[H]
			\begin{tabular}{ |p{2cm}|p{5cm}|p{7cm}|  }
			\hline
			\textbf{Operator} & \textbf{Description} & \textbf{Definition} \\ \hline
			\texttt{!} & \texttt{Logical NOT} & {Returns 0 given a truthy value and 1 given a falsey value.} \\ \hline
			\texttt{==} & \texttt{Equals} & {Evaluates to 1 if the two expressions are both numbers and have the same value, or 0 if the two expressions are both numbers that do not have the same value. If the two expressions are ranges, evaluates to 1 if the two ranges have the same dimensions and each cell of the first expression == the corresponding cell of the second expression} \\
			\texttt{!=} & \texttt{Not equals} & {Evaluates to 1 if the expressions are not the same.} \\
			\texttt{<} & \texttt{Less than} & {Evaluates to 1 if the first expression is less than the first.} \\
			\texttt{>} & \texttt{Greater than} & {Evaluates to 1 if the first expression is greater than the first.}. \\
			\texttt{<=} & \texttt{Less than or equals to} & {Evaluates to 1 if the first expression is less than or equals to the second.} \\
			\texttt{>=} & \texttt{Greater than or equals to} & {Evaluates to 1 if the first expression is less than or equals to the second.} \\ \hline
			\texttt{\&\&} & \texttt{Logical AND} & {Returns 1 if both expressions evaluate to truthy values, otherwise 0.} \\ \hline
			\texttt{||} & \texttt{Logical OR} & {Returns 1 if at least one of the two expressions evaluate to a truthy value, otherwise 0.} \\ \hline
			\end{tabular}
			\end{table}
		\subsection{Conditional Operators}
			The conditional operators can be used to create expressions that evaluate to a specified expression based on the truthiness of a specified expression. There are two types of conditional expressions, ternary expressions and \texttt{switch} expressions.
			
\subsubsection{Ternary Expressions}
\label{sec:Ternary}
A ternary expression, written as \texttt{cond-expr ? expr-if-true : expr-if-false} works like an if-else conditional statement. It evaluates to \texttt{expr-if-true} if \texttt{cond-expr} is numeric and truthy, or  \texttt{expr-if-false} if \texttt{cond-expr} is numeric and falsey. If \texttt{cond-expr} is empty, the expression evaluates to empty. Both expr-if-true and expr-if-false are mandatory.

\subsubsection{Switch Expressions}
\label{sec:Switch}			
A \texttt{switch} expression takes a optional condition, and a list of cases and expressions that the overall expression should evaluate to if the case applies. In the event that multiple cases are true, the expression of the first matching case encountered will be evaluated. An example is provided below:
\begin{lstlisting}
[1,1] foo := 3;
return switch (foo) {
	case 2: "foo is 2";
	case 3,4: "foo is 3 or 4";
	default: "none of the above";
}

/* Equivalently: */
return switch() {
	case foo == 2:
		"foo is 2";
	case foo == 3, foo == 4:
		"foo is 3 or 4";
	default:
		"none of the above";
}
\end{lstlisting}
The format for a \texttt{switch} statement is the keyword \texttt{switch}, followed by pair of parentheses that optionally contain an expression \texttt{switch-expr}, followed by a list of case clauses enclosed in curly braces and delimited by semicolons. A case clause consists of the keyword \texttt{case} followed by a comma-separated list of expressions \texttt{case-expr1 [, case-expr2, [...]]}, a colon, and an expression \texttt{match-expr}, or the keyword \texttt{default}, a colon, and an expression \texttt{default-expr}. If \texttt{switch-expr} is omitted, the value 1 is assumed. The \texttt{switch} expression evaluates to the \texttt{match-expr} for the first case where one of the \texttt{case-expr}s is equal to \texttt{switch-expr}, with equality defined as for the \texttt{==} operator, or \texttt{default-expr}, if none of the \texttt{case-expr}s is equal to \texttt{switch-expr} for any of the cases. 

The \texttt{switch} expression can be used to compactly represent what in most imperative languages would require a long string such as \texttt{if (cond1) \{...\} else if (cond2) \{...\}}.
\subsection {Function Calls}
A function expression consists of an identifier and an optional list of expressions enclosed in parentheses and separated by commas. The value of the expression is the result of applying the function to the arguments passed in as expressions. For more detail, see section~\ref{sec:Functions}.
\subsection{Range Expressions}
Range expressions are used to select part or all of a range. A range expression consists of a bare identifier, a bare range literal, or an expression and a selector. If a range expression has exactly 1 row and 1 column, the value of the expression is the value of the formula of the single cell of the range. If it has more than 1 row or more than 1 column, the value of the expression is the selected range. If the range has zero or fewer rows or zero or fewer columns, the value of the expression is \texttt{empty}. If a range expression with a selector would access a row index or column index greater than the number of rows or columns of the range, or a negative row or column index, the value of the expression is \texttt{empty}. 
\subsubsection{Slices}
A slice consists of an optional integer literal or expression \texttt{start}, a colon, and an optional integer literal or expression \texttt{end}, or a single integer literal or expression \texttt{index}. If \texttt{start} is omitted, it defaults to 0. If \texttt{end} is omitted, it defaults to the length of the dimension. A single \texttt{index} with no colon is equivalent to \texttt{index:index+1}. Enclosing \texttt{start} or \texttt{end} in square brackets is equivalent to the expression \texttt{row() + start} or \texttt{row() + end}, for a row slice, or \texttt{column() + start} or \texttt{column() + end} for a column slice. The slice includes \texttt{start} and excludes \texttt{end}, so the length of a slice is \texttt{end - start}. A negative value is interpreted as the length of the dimension minus the value.
			As mentioned above, the value of a range that is not 1 by 1 is a range, but the value of a 1 by 1 range is essentially dereferenced to the result of the cell formula.
\subsubsection{Selections}
A selection expression consists of an expression and a pair of slices separated by a comma and enclosed in square brackets, i.e. {[}\texttt{row\_slice, column\_slice}{]}. It can also be written as the hash symbol \texttt{\#} and an expression. As mentioned earlier, the composite \textbf{range} type has the ability to slice in both an absolute and relative fashion. If one of the dimensions of the range has length 1, the comma and the slice for that dimension can be omitted. If the comma is present but a slice is omitted, that slice defaults to {[}\texttt{0}{]} for a slice corresponding to a dimension of length greater than one, or \texttt{0} for a slice corresponding to a dimension of length one. \texttt{\#expr} is syntactic sugar for \texttt{expr}{[},{]}; for a range with more than column and more than one row, it denotes the position in the RHS expression corresponding to the position of cell on the left-hand-side of the formula assignment. For a range with only one column, it denotes the single cell in the same row as the cell on the left-hand-side of the assignment. For a range with only one row, it denotes the single cell in the same column as the cell on the left-hand-side of the assignment. These possibilities mean that there are multiple ways to slice ranges, which are illustrated below.\newline
\begin{lstlisting}
foo[1,2] /* This evaluates to the cell value in the second row and third column. */
foo[1,:] /* Evaluates to the range of cells in the second row of foo. */
foo[:,2] /* Evaluates to the range of cells in the third column of foo. */
foo[:,[1]] /* The internal brackets denote RELATIVE notation. 
In this case, 1 column right of the column of the left-hand-side cell. */ 

foo[1,] /* Equivalent to foo[1,[0]] if foo has more than one column
or foo[1,0] if foo has one column */

foo[5:, 7:] /* All cells starting from the 6th row and 8th column to the bottom right */

foo[[1:2], [5:7]] 
/* Selects the rows between the 1st and 2nd row after LHS row, and 
   between 5th and 7th column from LHS column */

#foo 
/* If foo has >=2 rows and >= 2 columns, equivalent to foo[[0],[0]]; 
   If foo has 1 row and multiple columns, equivalent to foo[0,[0]]; etc. */
\end{lstlisting}
\subsection{Precedence Expressions}
A precedence expression is used to force the evaluation of one expression before another, when that order of operation is required for functions with side-effects. It consists of an expression \texttt{prec-expr}, the precedence operator \texttt{->}, and an expression \texttt{succ-expr}. The value of the expression is \texttt{succ-expr}, but the value of \texttt{prec-expr} will be calculated first and the result ignored. The only functions with side effects in Extend are the built-in file I/O functions described in section~\ref{sec:IO} or user-defined functions that call those built-in functions; an example is located in that section.