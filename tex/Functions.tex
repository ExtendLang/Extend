\section{Functions}
\label{sec:Functions}
The bulk of an Extend program consists of functions. Although Extend has some features, such as immutability and lazy evaluation, that are inspired by functional languages, its functions are not \textit{first class objects}. All functions written purely in Extend are free of side effects, but some of the functions in the standard library, such as the file I/O functions described in section~\ref{sec:IO}, do have side effects.
\subsection{Format}
\label{sec:funcdecl}
As in most programming languages, the header of the function declares the parameters it accepts. The body of the function consists of an optional set of variable declarations and formula assignments, which can occur in any order, and a return statement, which must be the last statement in the function body. All variable declarations and formula assignments, in addition to the return statement, must be terminated by a semicolon.
This very simple function returns whatever value is passed into it:
\lstinputlisting{./samples/functions_simple.xtnd}
\subsection{Variable Declarations}
\label{sec:vardecl}
A variable declaration associates an identifier with a range of cells of the specified dimensions, which are listed in square brackets before the identifier. For convenience, if the square brackets and dimensions are omitted, the identifier will be associated with a 1x1 range. In addition, multiple identifiers, separated by commas, can be listed after the dimensions; all of these identifiers will be separate ranges, but with equal dimension sizes. The dimensions can be specified as any valid expression that evaluates to a Number, which will be rounded to the nearest signed 32-bit integer. If either dimension is zero or negative, or if the expression does not evaluate to a Number, a runtime error causing the program to halt will occur.
\begin{lstlisting}
[2, 5] foo; // Declares foo as a range with 2 rows and 5 columns
[m, n] bar; // Declares bar as a range with m rows and n columns
[3, 3] ham, eggs, spam; // Declares ham, eggs and spam as distinct 3x3 ranges
baz; // Declares baz as a 1x1 range
\end{lstlisting}
\subsection{Formula Assignment}
\label{sec:formula}
A formula assignment assigns an expression to a subset of the cells of a variable. Unlike most imperative languages, this expression is not immediately evaluated, but is instead only evaluated if and when it is needed to calculate the return value of the function. A formula assignment consists of an identifier, an optional pair of slices enclosed in square brackets specifying the subset of the cells that the assignment applies to, an \texttt{=}, and an expression, followed by a semicolon. As with the expressions specifying the dimensions of a range, these slices specifying the cell subset can contain arbitrary expressions, as long as the expression taken as a whole evaluates to a Number, which will be rounded to the nearest signed 32-bit integer. Negative numbers are legal in these slices, and correspond to (dimension length + expression).
\begin{lstlisting}
[5, 2] foo, bar, baz; // Declares foo, bar, and baz as distinct 5x2 ranges
foo[0,0] = 42; // Assigns the expression 42 to the first cell of the first row of foo
foo[0,1] = foo[0,0] * 2; // Assigns (foo[0,0] * 2) to the 2nd cell of the 1st row of foo
bar = 3.14159; // Assigns pi to every cell of every row of bar
baz[1:-1,0:1] = 2.71828; // Assigns e to cells (1,0) through (3,1) of baz

/* The next line assigns foo[[-1],0] + 1 to every cell in
   both columns of foo, besides the first row */
foo[1:,:] = foo[[-1],0] + 2;
\end{lstlisting}
The last line of the source snippet above demonstrates the idiomatic Extend way of simulating an imperative language's loop; foo[4,0] would evaluate to 42+2+2+2+2 = 50 and foo[4,1] would evaluate to (42*2)+2+2+2+2 = 92.
\subsubsection{Combined Variable Declaration and Formula Assignment}
For convenience, a variable declaration and a formula assignment to all cells of that variable can be combined on a single line by inserting a \texttt{:=} and an expression after the identifier. Multiple variables and assignments, separated by commas, can be declared on a single line as well. All global variables must be defined using the combined declaration and formula assignment syntax.
\begin{lstlisting}
/* Creates two 2x2 ranges; every cell of foo evaluates to 1 and every cell of
   bar evaluates to 2. */
[2,2] foo := 1, bar := 2;
\end{lstlisting}
\subsubsection{Formula Assignment Errors}
If the developer writes code in such a way that more than one formula applies to a cell, this causes a compile-time error if the compiler can detect it or a runtime error if the compiler cannot detect it in advance and the cell is evaluated. If there is no formula assigned to a cell, the cell will evaluate to \texttt{empty}.
\subsection{Parameter Declarations}
If a parameter is declared with an identifier for the dimensions, instead of an integer literal, that identifier will contain the dimension size of the argument inside the function. Therefore, if a certain operation should be applied to a range of numbers of unknown size, the size can be inferred at runtime:
\lstinputlisting{./samples/functions_dim_range_v.xtnd}
This function will add 1 to each element in arg. Notice, that \texttt{m} is used across the function as a variable identifier to apply the operation to the range. If the same identifier is used for the dimensions of multiple arguments, a run-time error will occur if the sizes of the arguments are not consistent. 
\subsection{Application on Ranges}
Extend gives the developer the power to easily apply operations in a functional style on ranges. As outlined in the section above, there are various ways to apply functions to ranges. A feature unique to Extend is the powerful operation on values and ranges. To apply a function on a per cell basis, the corresponding variable needs to be preceded by "\#". The following function applies cell wise addition:
\lstinputlisting{./samples/functions_range_single.xtnd}
While both function above result in the same value, and only show the syntactical difference. If we wanted each cell to to be the square root divided by the sum of the input we have the following:
\lstinputlisting{./samples/functions_range_mix.xtnd}
Notice that \texttt{arg} is only once preceded by \texttt{\#}.
\subsection{Dependencies Illustrated}
The dependency resolution is another asset that sets Extend apart from other languages. Most languages compile ordinarily and execute the given commands sequentially. Extend builds a dependency graph. The advantage of this is that only relevant code segments will be executed. Given the function
\lstinputlisting{./samples/functions_dep_graph.xtnd}
The dependency graph will look like this: \newline
\begin{tikzpicture}[->,>=stealth',shorten >=0pt,auto,node distance=3cm,
        thick,main/.style={circle,draw,minimum size=0.6cm,inner sep=0pt]}]
		\node [main] (1) at (0, 2) {arg1};
		\node [main] (2) at (4, 2) {arg2};
		\node [main] (3) at (0, 0) {bar = \#arg + 1};
		\node [main] (4) at (0, -3) {baz = bar + arg2};
		\node [main] (5) at (0, -6) {foo = baz};
		\draw (1) to (3);
		\draw (3) to (4);
		\draw (4) to (5);
		\draw (2) to (4);
\end{tikzpicture} \newline
Notice that \texttt{faz} does not appear in the graph, because it is not relevant for the return value. Ultimately this graph enables Extend to find the leaves, evaluate code paths in the best configuration and even in parallel.
